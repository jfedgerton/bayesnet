u = u,
x = x,
y = y)
stan.dta$x <- as.matrix(stan.dta$x)
rstan_options(auto_write = TRUE)
options(mc.cores = cores)
# fit the model using STAN
scode <- "data {
int<lower=1> L1;		// number of level 1 predictors
int<lower=1> L2;		// number of level 2 predictors
int<lower=1> GD;		// number of node group pairs
int<lower=0> D;		// number of potential ties
int<lower=1, upper=GD> group[D]; // numerical indicator of edge group (group_ID)
row_vector[L1] u[D];		// level 1 predictors
row_vector[L2] x[D];		// level 2 predictors
int<lower=0,upper=1> y[D];	// ties (outcome)
}
parameters {
real<lower=0> tau;		// sociality dispersion
vector[GD] a;       // separate edge group intercepts
real mu;            // group population intercept
vector[L1] beta1;		// L1 predictor coefficients
vector[L2] beta2;		// L2 predictor coefficients
}
transformed parameters{
vector[D] phi; // container for linear predictor
vector[D] alpha; // container for linear predictor
for (i in 1:D) {
alpha[i] = a[group[i]] + dot_product(beta1, u[i]);
phi[i] = dot_product(beta2, x[i]) + 0.5 * (alpha[i]);
}
}
model {
mu ~ normal(0,1);
tau ~ gamma(0.001, 0.001);
a ~ normal(mu,tau);
beta1 ~ normal(0, 1);
beta2 ~ normal(0, 1);
y ~ bernoulli_logit(phi);
}
generated quantities {
vector[D] predictions;
for (i in 1:D) {
predictions[i] = bernoulli_rng(
inv_logit(
dot_product(beta2, x[i]) + 0.5 * normal_rng( a[group[i]] +
dot_product(beta1, u[i]),tau)
)
);
}
}"
if(!is.null(seed)){
set.seed(seed)
cat("Setting seed at the default value of 12345 for the seed argument.")
} else {
warning("Note: This function relies simulation.  Consider specifying a seed to set to ensure replicability.")
}
stan.fit <- stan(model_code = scode,
data=stan.dta, chains=chains, warmup=warmup, iter=iter)
stan.output = rstan::extract(stan.fit)
var.names.stage1 <- names(u)
colnames(stan.output$beta1) <- var.names.stage1
var.names.stage2 <- names(x)
colnames(stan.output$beta2) <- var.names.stage2
return(list(stan.fit = stan.fit, stan.output = stan.output, stan.dta = stan.dta, group.id = group.id, form.stage.1 = formula.stage.1, form.stage.2 = formula.stage.2))
}
} else {
cat('Compile group data before running meergm.')
}
}
model.1 <- meergm(formula.stage.1 = "nodematch('rural')+absdiff('size')",
formula.stage.2 = "absdiff('age') + triangle + degree(2)",
group.data = groups,
net = net)
save(model.1, file = "C:/Users/jared/Dropbox/Projects/Hierarchical ERGM/Test output/model_simulation.RData")
model.1
meergm <- function(formula.stage.1, formula.stage.2, group.data, net, chains = 4, warmup = 100, iter = 5000, seed = 12345)
{
require('ergm')
require('dplyr')
require('fergm')
require('rstan')
if (exists('group.data') && is.data.frame(get('group.data')))
{
if (grepl("gwesp", formula.stage.2) == T){
warning("Curved spaced parameters may be biased.")
}
if(network::is.directed(net) == T)
{
cat("Does not support directed networks")
} else
{
ties <- prepare_meergm_data(net = net, group.data = group.data, form = formula.stage.2)
ties$Group1 <- factor(ties$Group1)
ties$Group2 <- factor(ties$Group2)
group.data$Group1   <- factor(group.data$Group1)
group.data$Group2   <- factor(group.data$Group2)
group.data$Group_ID <- factor(group.data$Group_ID)
ties$Group1 <- as.character(ties$Group1)
ties$Group2 <- as.character(ties$Group2)
group.data$Group1 <- as.character(group.data$Group1)
group.data$Group2 <- as.character(group.data$Group2)
group.data$Group_ID <- as.character(group.data$Group_ID)
temp_gr <- group.data
temp_gr$Group1 <- group.data$Group2
temp_gr$Group2 <- group.data$Group1
ties_temp <- dplyr::bind_rows(group.data, temp_gr)
ties_temp <-   dplyr::distinct(ties_temp,
Group1, Group2, Group_ID, .keep_all = T)
ties_temp <- right_join(ties_temp, ties, by = c("Group1", "Group2"))
ties_temp <- dplyr::arrange(ties_temp, Group_ID)
if (nrow(ties_temp) == nrow(ties))
{
ties = ties_temp
} else
{
cat("Error in group identification.")
}
cat("Starting data preparation")
## Pull out the first stage variables
first_stage_variables <- names(group.data)
first_stage_variables <- first_stage_variables[!(first_stage_variables %in% c("Group1", "Group2", "intercept", "Group_ID"))]
u <- ties[,names(ties) %in% first_stage_variables]
## Pull out the second stage variables
second_stage_variables <- names(ties)
second_stage_variables <- second_stage_variables[!(second_stage_variables %in% c(c("Y", "Sociality1", "Sociality2"), names(group.data)))]
x <- ties[,names(ties) %in% second_stage_variables]
g.idx <- as.numeric(as.factor(ties$Group_ID))
y <- ties[,"Y"]
group.id <- unique(cbind(g.idx, ties$Group_ID))
stan.dta  <- list(L1 = ncol(u),
L2 = ncol(x),
GD = nrow(group.data),
D = nrow(x),
group = g.idx,
u = u,
x = x,
y = y)
stan.dta$x <- as.matrix(stan.dta$x)
rstan_options(auto_write = TRUE)
options(mc.cores = cores)
# fit the model using STAN
scode <- "data {
int<lower=1> L1;		// number of level 1 predictors
int<lower=1> L2;		// number of level 2 predictors
int<lower=1> GD;		// number of node group pairs
int<lower=0> D;		// number of potential ties
int<lower=1, upper=GD> group[D]; // numerical indicator of edge group (group_ID)
row_vector[L1] u[D];		// level 1 predictors
row_vector[L2] x[D];		// level 2 predictors
int<lower=0,upper=1> y[D];	// ties (outcome)
}
parameters {
real<lower=0> tau;		// sociality dispersion
vector[GD] a;       // separate edge group intercepts
real mu;            // group population intercept
vector[L1] beta1;		// L1 predictor coefficients
vector[L2] beta2;		// L2 predictor coefficients
}
transformed parameters{
vector[D] phi; // container for linear predictor
vector[D] alpha; // container for linear predictor
for (i in 1:D) {
alpha[i] = a[group[i]] + dot_product(beta1, u[i]);
phi[i] = dot_product(beta2, x[i]) + 0.5 * (alpha[i]);
}
}
model {
mu ~ normal(0,1);
tau ~ gamma(0.001, 0.001);
a ~ normal(mu,tau);
beta1 ~ normal(0, 1);
beta2 ~ normal(0, 1);
y ~ bernoulli_logit(phi);
}
generated quantities {
vector[D] predictions;
for (i in 1:D) {
predictions[i] = bernoulli_rng(
inv_logit(
dot_product(beta2, x[i]) + 0.5 * normal_rng( a[group[i]] +
dot_product(beta1, u[i]),tau)
)
);
}
}"
if(!is.null(seed)){
set.seed(seed)
cat("Setting seed at the default value of 12345 for the seed argument.")
} else {
warning("Note: This function relies simulation.  Consider specifying a seed to set to ensure replicability.")
}
stan.fit <- stan(model_code = scode,
data=stan.dta, chains=chains, warmup=warmup, iter=iter)
stan.output = rstan::extract(stan.fit)
var.names.stage1 <- names(u)
colnames(stan.output$beta1) <- var.names.stage1
var.names.stage2 <- names(x)
colnames(stan.output$beta2) <- var.names.stage2
return(list(stan.fit = stan.fit, stan.output = stan.output, stan.dta = stan.dta, group.id = group.id, form.stage.1 = formula.stage.1, form.stage.2 = formula.stage.2))
}
} else {
cat('Compile group data before running meergm.')
}
}
model.1 <- meergm(formula.stage.1 = "nodematch('rural')+absdiff('size')",
formula.stage.2 = "absdiff('age') + triangle + degree(2)",
group.data = groups,
net = net)
save(model.1, file = "C:/Users/jared/Dropbox/Projects/Hierarchical ERGM/Test output/model_simulation.RData")
model.1
meergm <- function(formula.stage.1, formula.stage.2, group.data, net, chains = 4, warmup = 100, iter = 5000, cores = 2, seed = 12345)
{
require('ergm')
require('dplyr')
require('fergm')
require('rstan')
if (exists('group.data') && is.data.frame(get('group.data')))
{
if (grepl("gwesp", formula.stage.2) == T){
warning("Curved spaced parameters may be biased.")
}
if(network::is.directed(net) == T)
{
cat("Does not support directed networks")
} else
{
ties <- prepare_meergm_data(net = net, group.data = group.data, form = formula.stage.2)
ties$Group1 <- factor(ties$Group1)
ties$Group2 <- factor(ties$Group2)
group.data$Group1   <- factor(group.data$Group1)
group.data$Group2   <- factor(group.data$Group2)
group.data$Group_ID <- factor(group.data$Group_ID)
ties$Group1 <- as.character(ties$Group1)
ties$Group2 <- as.character(ties$Group2)
group.data$Group1 <- as.character(group.data$Group1)
group.data$Group2 <- as.character(group.data$Group2)
group.data$Group_ID <- as.character(group.data$Group_ID)
temp_gr <- group.data
temp_gr$Group1 <- group.data$Group2
temp_gr$Group2 <- group.data$Group1
ties_temp <- dplyr::bind_rows(group.data, temp_gr)
ties_temp <-   dplyr::distinct(ties_temp,
Group1, Group2, Group_ID, .keep_all = T)
ties_temp <- right_join(ties_temp, ties, by = c("Group1", "Group2"))
ties_temp <- dplyr::arrange(ties_temp, Group_ID)
if (nrow(ties_temp) == nrow(ties))
{
ties = ties_temp
} else
{
cat("Error in group identification.")
}
cat("Starting data preparation")
## Pull out the first stage variables
first_stage_variables <- names(group.data)
first_stage_variables <- first_stage_variables[!(first_stage_variables %in% c("Group1", "Group2", "intercept", "Group_ID"))]
u <- ties[,names(ties) %in% first_stage_variables]
## Pull out the second stage variables
second_stage_variables <- names(ties)
second_stage_variables <- second_stage_variables[!(second_stage_variables %in% c(c("Y", "Sociality1", "Sociality2"), names(group.data)))]
x <- ties[,names(ties) %in% second_stage_variables]
g.idx <- as.numeric(as.factor(ties$Group_ID))
y <- ties[,"Y"]
group.id <- unique(cbind(g.idx, ties$Group_ID))
stan.dta  <- list(L1 = ncol(u),
L2 = ncol(x),
GD = nrow(group.data),
D = nrow(x),
group = g.idx,
u = u,
x = x,
y = y)
stan.dta$x <- as.matrix(stan.dta$x)
rstan_options(auto_write = TRUE)
options(mc.cores = cores)
# fit the model using STAN
scode <- "data {
int<lower=1> L1;		// number of level 1 predictors
int<lower=1> L2;		// number of level 2 predictors
int<lower=1> GD;		// number of node group pairs
int<lower=0> D;		// number of potential ties
int<lower=1, upper=GD> group[D]; // numerical indicator of edge group (group_ID)
row_vector[L1] u[D];		// level 1 predictors
row_vector[L2] x[D];		// level 2 predictors
int<lower=0,upper=1> y[D];	// ties (outcome)
}
parameters {
real<lower=0> tau;		// sociality dispersion
vector[GD] a;       // separate edge group intercepts
real mu;            // group population intercept
vector[L1] beta1;		// L1 predictor coefficients
vector[L2] beta2;		// L2 predictor coefficients
}
transformed parameters{
vector[D] phi; // container for linear predictor
vector[D] alpha; // container for linear predictor
for (i in 1:D) {
alpha[i] = a[group[i]] + dot_product(beta1, u[i]);
phi[i] = dot_product(beta2, x[i]) + 0.5 * (alpha[i]);
}
}
model {
mu ~ normal(0,1);
tau ~ gamma(0.001, 0.001);
a ~ normal(mu,tau);
beta1 ~ normal(0, 1);
beta2 ~ normal(0, 1);
y ~ bernoulli_logit(phi);
}
generated quantities {
vector[D] predictions;
for (i in 1:D) {
predictions[i] = bernoulli_rng(
inv_logit(
dot_product(beta2, x[i]) + 0.5 * normal_rng( a[group[i]] +
dot_product(beta1, u[i]),tau)
)
);
}
}"
if(!is.null(seed)){
set.seed(seed)
cat("Setting seed at the default value of 12345 for the seed argument.")
} else {
warning("Note: This function relies simulation.  Consider specifying a seed to set to ensure replicability.")
}
stan.fit <- stan(model_code = scode,
data=stan.dta, chains=chains, warmup=warmup, iter=iter)
stan.output = rstan::extract(stan.fit)
var.names.stage1 <- names(u)
colnames(stan.output$beta1) <- var.names.stage1
var.names.stage2 <- names(x)
colnames(stan.output$beta2) <- var.names.stage2
return(list(stan.fit = stan.fit, stan.output = stan.output, stan.dta = stan.dta, group.id = group.id, form.stage.1 = formula.stage.1, form.stage.2 = formula.stage.2))
}
} else {
cat('Compile group data before running meergm.')
}
}
model.1 <- meergm(formula.stage.1 = "nodematch('rural')+absdiff('size')",
formula.stage.2 = "absdiff('age') + triangle + degree(2)",
group.data = groups,
net = net)
save(model.1, file = "C:/Users/jared/Dropbox/Projects/Hierarchical ERGM/Test output/model_simulation.RData")
plot(model.1)
model.1$stan.fit)
model.1$stan.fit
plot(model.1$stan.fit)
plot(model.1$stan.output)
plot(model.1$stan.dta)
model.1$form.stage.2
model.1$form.stage.3
model.1$form.stage.1
model.1$stan.fit
plot(model.1$stan.fit$`beta2[1]`)
plot(model.1$stan.fit)
coef_plot <- function(meergm.fit = NULL, custom_var_names = NULL){
require(ggplot2)
require(RColorBrewer)
stage.1 <- data.frame(meergm.fit$stan.output$beta1)
stage.2 <- data.frame(meergm.fit$stan.output$beta2)
group.estimates <- data.frame(meergm.fit$stan.output$a)
group.estimates.tau <- data.frame(meergm.fit$stan.output$tau)
colnames(group.estimates) <- paste0("Group", 1:ncol(group.estimates))
colnames(group.estimates.tau) <- "Tau"
all_var_to_plot <- c(colnames(stage.1), colnames(stage.2), colnames(group.estimates), colnames(group.estimates.tau))
data_to_plot <- dplyr::bind_cols(stage.1, stage.2,
group.estimates, group.estimates.tau)
for (coef_loop in 1:length(all_var_to_plot))
{
temp_data <- data.frame(data_to_plot[,names(data_to_plot) %in% all_var_to_plot[coef_loop]])
colnames(temp_data) <- "Var_Plot"
iteration_check <- nrow(temp_data)/ncol(meergm.fit$stan.fit)
temp_data$iteration <- rep(1:iteration_check, ncol(meergm.fit$stan.fit))
temp_data$chains <- as.character(sort(rep(1:ncol(meergm.fit$stan.fit), iteration_check)))
dens_plot <- ggplot(temp_data) +
geom_density(aes(Var_Plot), fill = "lightblue") +
labs(x = paste0("n = ", nrow(data_to_plot)),
title = paste0("Posterior Distribution ", all_var_to_plot[coef_loop])) +
theme_bw()
trace_plot <- ggplot(temp_data) +
geom_line(aes(x = iteration, y = Var_Plot, col = chains)) +
labs(x = paste0("iterations = ", iteration_check), y = all_var_to_plot[coef_loop],
title = paste0("Trace Plot ", all_var_to_plot[coef_loop])) +
theme_bw() +
scale_color_brewer(palette = "Set1") +
theme(legend.position="none")
gridExtra::grid.arrange(dens_plot, trace_plot, ncol=2)
}
}
coef_plot(meergm.fit = model.1)
model.1$stan.fit
model.1$stan.fit$`a[1]`
model.1$stan.fit
model.1$stan.output$predictions
plot(model.1$stan.output)
ncols(model.1$stan.output)
ncol(model.1$stan.output)
colnames(model.1$stan.output)
model.1$stan.output[1,]
model.1$stan.output
row.names(model.1$stan.output$tau)
colnames(model.1$stan.output$tau)
model.1$stan.output$tau[1,]
model.1$stan.output$tau
dim(model.1$stan.output$tau)
coef_plot <- function(meergm.fit = NULL, custom_var_names = NULL){
require(ggplot2)
require(RColorBrewer)
stage.1 <- data.frame(meergm.fit$stan.output$beta1)
stage.2 <- data.frame(meergm.fit$stan.output$beta2)
group.estimates <- data.frame(meergm.fit$stan.output$a)
group.estimates.tau <- data.frame(meergm.fit$stan.output$tau)
colnames(group.estimates) <- paste0("Group", 1:ncol(group.estimates))
colnames(group.estimates.tau) <- "Tau"
all_var_to_plot <- c(colnames(stage.1), colnames(stage.2), colnames(group.estimates), colnames(group.estimates.tau))
data_to_plot <- dplyr::bind_cols(stage.1, stage.2,
group.estimates, group.estimates.tau)
for (coef_loop in 1:length(all_var_to_plot))
{
temp_data <- data.frame(data_to_plot[,names(data_to_plot) %in% all_var_to_plot[coef_loop]])
colnames(temp_data) <- "Var_Plot"
iteration_check <- nrow(temp_data)/ncol(meergm.fit$stan.fit)
temp_data$iteration <- rep(1:iteration_check, ncol(meergm.fit$stan.fit))
temp_data$chains <- as.character(sort(rep(1:ncol(meergm.fit$stan.fit), iteration_check)))
dens_plot <- ggplot(temp_data) +
geom_density(aes(Var_Plot), fill = "lightblue", adjust = 1) +
labs(x = paste0("n = ", nrow(data_to_plot)),
title = paste0("Posterior Distribution ", all_var_to_plot[coef_loop])) +
theme_bw()
trace_plot <- ggplot(temp_data) +
geom_line(aes(x = iteration, y = Var_Plot, col = chains)) +
labs(x = paste0("iterations = ", iteration_check), y = all_var_to_plot[coef_loop],
title = paste0("Trace Plot ", all_var_to_plot[coef_loop])) +
theme_bw() +
scale_color_brewer(palette = "Set1") +
theme(legend.position="none")
gridExtra::grid.arrange(dens_plot, trace_plot, ncol=2)
}
}
coef_plot(meergm.fit = model.1)
coef_plot <- function(meergm.fit = NULL, custom_var_names = NULL){
require(ggplot2)
require(RColorBrewer)
stage.1 <- data.frame(meergm.fit$stan.output$beta1)
stage.2 <- data.frame(meergm.fit$stan.output$beta2)
group.estimates <- data.frame(meergm.fit$stan.output$a)
group.estimates.tau <- data.frame(meergm.fit$stan.output$tau)
colnames(group.estimates) <- paste0("Group", 1:ncol(group.estimates))
colnames(group.estimates.tau) <- "Tau"
all_var_to_plot <- c(colnames(stage.1), colnames(stage.2), colnames(group.estimates), colnames(group.estimates.tau))
data_to_plot <- dplyr::bind_cols(stage.1, stage.2,
group.estimates, group.estimates.tau)
for (coef_loop in 1:length(all_var_to_plot))
{
temp_data <- data.frame(data_to_plot[,names(data_to_plot) %in% all_var_to_plot[coef_loop]])
colnames(temp_data) <- "Var_Plot"
iteration_check <- nrow(temp_data)/ncol(meergm.fit$stan.fit)
temp_data$iteration <- rep(1:iteration_check, ncol(meergm.fit$stan.fit))
temp_data$chains <- as.character(sort(rep(1:ncol(meergm.fit$stan.fit), iteration_check)))
dens_plot <- ggplot(temp_data) +
geom_density(aes(Var_Plot), fill = "lightblue", adjust = 2) +
labs(x = paste0("n = ", nrow(data_to_plot)),
title = paste0("Posterior Distribution ", all_var_to_plot[coef_loop])) +
theme_bw()
trace_plot <- ggplot(temp_data) +
geom_line(aes(x = iteration, y = Var_Plot, col = chains)) +
labs(x = paste0("iterations = ", iteration_check), y = all_var_to_plot[coef_loop],
title = paste0("Trace Plot ", all_var_to_plot[coef_loop])) +
theme_bw() +
scale_color_brewer(palette = "Set1") +
theme(legend.position="none")
gridExtra::grid.arrange(dens_plot, trace_plot, ncol=2)
}
}
coef_plot(meergm.fit = model.1)
coef_plot <- function(meergm.fit = NULL, custom_var_names = NULL){
require(ggplot2)
require(RColorBrewer)
stage.1 <- data.frame(meergm.fit$stan.output$beta1)
stage.2 <- data.frame(meergm.fit$stan.output$beta2)
group.estimates <- data.frame(meergm.fit$stan.output$a)
group.estimates.tau <- data.frame(meergm.fit$stan.output$tau)
colnames(group.estimates) <- paste0("Group", 1:ncol(group.estimates))
colnames(group.estimates.tau) <- "Tau"
all_var_to_plot <- c(colnames(stage.1), colnames(stage.2), colnames(group.estimates), colnames(group.estimates.tau))
data_to_plot <- dplyr::bind_cols(stage.1, stage.2,
group.estimates, group.estimates.tau)
for (coef_loop in 1:length(all_var_to_plot))
{
temp_data <- data.frame(data_to_plot[,names(data_to_plot) %in% all_var_to_plot[coef_loop]])
colnames(temp_data) <- "Var_Plot"
iteration_check <- nrow(temp_data)/ncol(meergm.fit$stan.fit)
temp_data$iteration <- rep(1:iteration_check, ncol(meergm.fit$stan.fit))
temp_data$chains <- as.character(sort(rep(1:ncol(meergm.fit$stan.fit), iteration_check)))
dens_plot <- ggplot(temp_data) +
geom_density(aes(Var_Plot), fill = "lightblue", adjust = 3) +
labs(x = paste0("n = ", nrow(data_to_plot)),
title = paste0("Posterior Distribution ", all_var_to_plot[coef_loop])) +
theme_bw()
trace_plot <- ggplot(temp_data) +
geom_line(aes(x = iteration, y = Var_Plot, col = chains)) +
labs(x = paste0("iterations = ", iteration_check), y = all_var_to_plot[coef_loop],
title = paste0("Trace Plot ", all_var_to_plot[coef_loop])) +
theme_bw() +
scale_color_brewer(palette = "Set1") +
theme(legend.position="none")
gridExtra::grid.arrange(dens_plot, trace_plot, ncol=2)
}
}
coef_plot(meergm.fit = model.1)
